// Code generated by iacg; DO NOT EDIT.
package tke

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	tke "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/tke/v20180525"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func DataSourceTencentCloudKubernetesClusterNodePools() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceTencentCloudKubernetesClusterNodePoolsRead,
		Schema: map[string]*schema.Schema{
			"cluster_id": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "ID of the cluster.",
			},

			"filters": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "NodePoolsName, Filter according to the node pool name, type: String, required: no. NodePoolsId, Filter according to the node pool ID, type: String, required: no. tags, Filter according to the label key value pairs, type: String, required: no. tag:tag-key, Filter according to the label key value pairs, type: String, required: no.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "The attribute name, if there are multiple filters, the relationship between the filters is a logical AND relationship.",
						},
						"values": {
							Type:        schema.TypeSet,
							Required:    true,
							Description: "Attribute values, if there are multiple values in the same filter, the relationship between values under the same filter is a logical OR relationship.",
							Elem: &schema.Schema{
								Type: schema.TypeString,
							},
						},
					},
				},
			},

			"node_pool_set": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "Node Pool List.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"node_pool_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of the node pool.",
						},
						"name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Name of the node pool.",
						},
						"cluster_instance_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of the cluster.",
						},
						"life_state": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Life cycle state of the node pool, include: creating, normal, updating, deleting, deleted.",
						},
						"launch_configuration_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of launch configuration.",
						},
						"autoscaling_group_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of autoscaling group.",
						},
						"labels": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Labels of the node pool.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Name in the map table.",
									},
									"value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Value in the map table.",
									},
								},
							},
						},
						"taints": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Labels of the node pool.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Key of taints mark.",
									},
									"value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Value of taints mark.",
									},
									"effect": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Effect of taints mark.",
									},
								},
							},
						},
						"node_count_summary": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Node List.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"manually_added": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "Manually managed nodes.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"joining": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Number of nodes joining.",
												},
												"initializing": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Number of nodes in initialization.",
												},
												"normal": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Normal number of nodes.",
												},
												"total": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Total number of nodes.",
												},
											},
										},
									},
									"autoscaling_added": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "Automatically managed nodes.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"joining": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Number of nodes joining.",
												},
												"initializing": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Number of nodes in initialization.",
												},
												"normal": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Normal number of nodes.",
												},
												"total": {
													Type:        schema.TypeInt,
													Computed:    true,
													Description: "Total number of nodes.",
												},
											},
										},
									},
								},
							},
						},
						"autoscaling_group_status": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Status information.",
						},
						"max_nodes_num": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Maximum number of nodes.",
						},
						"min_nodes_num": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Minimum number of nodes.",
						},
						"desired_nodes_num": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Expected number of nodes.",
						},
						"node_pool_os": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Node Pool OS Name.",
						},
						"os_customize_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Mirror version of container.",
						},
						"image_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of image.",
						},
						"desired_pod_num": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "When the cluster belongs to the node podCIDR size customization mode, the node pool needs to have the pod number attribute.",
						},
						"user_script": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "User defined scripts.",
						},
						"tags": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Resource tags.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"key": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Label key.",
									},
									"value": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Label value.",
									},
								},
							},
						},
						"deletion_protection": {
							Type:        schema.TypeBool,
							Computed:    true,
							Description: "Remove protection switch.",
						},
						"extra_args": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Node configuration.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"kubelet": {
										Type:        schema.TypeSet,
										Computed:    true,
										Description: "Kubelet custom parameters.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
								},
							},
						},
						"gpu_args": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "GPU driver related parameters.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"mig_enable": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: "Is the MIG feature enabled.",
									},
									"driver": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "GPU driver version information.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"version": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "GPU driver or CUDA version.",
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "GPU driver or CUDA name.",
												},
											},
										},
									},
									"cuda": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "CUDA version information.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"version": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "GPU driver or CUDA version.",
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "GPU driver or CUDA name.",
												},
											},
										},
									},
									"cudnn": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "CuDNN version information.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"version": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Version of cuDNN.",
												},
												"name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Name of cuDNN.",
												},
												"doc_name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Doc name of cuDNN.",
												},
												"dev_name": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Dev name of cuDNN.",
												},
											},
										},
									},
									"custom_driver": {
										Type:        schema.TypeList,
										Computed:    true,
										Description: "Custom GPU driver information.",
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"address": {
													Type:        schema.TypeString,
													Computed:    true,
													Description: "Custom GPU driver address link.",
												},
											},
										},
									},
								},
							},
						},
						"docker_graph_path": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Dockerd --graph specified value, default to /var/lib/docker.",
						},
						"data_disks": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: "Multi disk data disk mounting information.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"disk_type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Cloud disk type.",
									},
									"file_system": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "File system(ext3/ext4/xfs).",
									},
									"disk_size": {
										Type:        schema.TypeInt,
										Computed:    true,
										Description: "Cloud disk size(G).",
									},
									"auto_format_and_mount": {
										Type:        schema.TypeBool,
										Computed:    true,
										Description: "Whether to automate the format disk and mount it.",
									},
									"mount_target": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Mount directory.",
									},
									"disk_partition": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "Mount device name or partition name.",
									},
								},
							},
						},
						"unschedulable": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: "Is it not schedulable.",
						},
						"pre_start_user_script": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "User defined script, executed before User Script.",
						},
					},
				},
			},

			"result_output_file": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Used to save results.",
			},
		},
	}
}

func dataSourceTencentCloudKubernetesClusterNodePoolsRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("data_source.tencentcloud_kubernetes_cluster_node_pools.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(nil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TkeService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	paramMap := make(map[string]interface{})
	if v, ok := d.GetOk("cluster_id"); ok {
		paramMap["ClusterId"] = helper.String(v.(string))
	}

	if v, ok := d.GetOk("filters"); ok {
		filtersSet := v.([]interface{})
		tmpSet := make([]*tke.Filter, 0, len(filtersSet))
		for _, item := range filtersSet {
			filtersMap := item.(map[string]interface{})
			filter := tke.Filter{}
			if v, ok := filtersMap["name"]; ok {
				filter.Name = helper.String(v.(string))
			}
			if v, ok := filtersMap["values"]; ok {
				valuesSet := v.(*schema.Set).List()
				for i := range valuesSet {
					values := valuesSet[i].(string)
					filter.Values = append(filter.Values, helper.String(values))
				}
			}
			tmpSet = append(tmpSet, &filter)
		}
		paramMap["Filters"] = tmpSet
	}

	var respData []*tke.NodePool
	err := resource.Retry(tccommon.ReadRetryTimeout, func() *resource.RetryError {
		result, e := service.DescribeKubernetesClusterNodePoolsByFilter(ctx, paramMap)
		if e != nil {
			return tccommon.RetryError(e)
		}
		respData = result
		return nil
	})
	if err != nil {
		return err
	}

	ids := make([]string, 0, len(respData))
	nodePoolSetList := make([]map[string]interface{}, 0, len(respData))
	if respData != nil {
		for _, nodePoolSet := range respData {
			nodePoolSetMap := map[string]interface{}{}

			var nodePoolId string
			if nodePoolSet.NodePoolId != nil {
				nodePoolSetMap["node_pool_id"] = nodePoolSet.NodePoolId
				nodePoolId = *nodePoolSet.NodePoolId
			}

			if nodePoolSet.Name != nil {
				nodePoolSetMap["name"] = nodePoolSet.Name
			}

			if nodePoolSet.ClusterInstanceId != nil {
				nodePoolSetMap["cluster_instance_id"] = nodePoolSet.ClusterInstanceId
			}

			if nodePoolSet.LifeState != nil {
				nodePoolSetMap["life_state"] = nodePoolSet.LifeState
			}

			if nodePoolSet.LaunchConfigurationId != nil {
				nodePoolSetMap["launch_configuration_id"] = nodePoolSet.LaunchConfigurationId
			}

			if nodePoolSet.AutoscalingGroupId != nil {
				nodePoolSetMap["autoscaling_group_id"] = nodePoolSet.AutoscalingGroupId
			}

			labelsList := make([]map[string]interface{}, 0, len(nodePoolSet.Labels))
			if nodePoolSet.Labels != nil {
				for _, labels := range nodePoolSet.Labels {
					labelsMap := map[string]interface{}{}

					if labels.Name != nil {
						labelsMap["name"] = labels.Name
					}

					if labels.Value != nil {
						labelsMap["value"] = labels.Value
					}

					labelsList = append(labelsList, labelsMap)
				}

				nodePoolSetMap["labels"] = labelsList
			}
			taintsList := make([]map[string]interface{}, 0, len(nodePoolSet.Taints))
			if nodePoolSet.Taints != nil {
				for _, taints := range nodePoolSet.Taints {
					taintsMap := map[string]interface{}{}

					if taints.Key != nil {
						taintsMap["key"] = taints.Key
					}

					if taints.Value != nil {
						taintsMap["value"] = taints.Value
					}

					if taints.Effect != nil {
						taintsMap["effect"] = taints.Effect
					}

					taintsList = append(taintsList, taintsMap)
				}

				nodePoolSetMap["taints"] = taintsList
			}
			nodeCountSummaryMap := map[string]interface{}{}

			if nodePoolSet.NodeCountSummary != nil {
				manuallyAddedMap := map[string]interface{}{}

				if nodePoolSet.NodeCountSummary.ManuallyAdded != nil {
					if nodePoolSet.NodeCountSummary.ManuallyAdded.Joining != nil {
						manuallyAddedMap["joining"] = nodePoolSet.NodeCountSummary.ManuallyAdded.Joining
					}

					if nodePoolSet.NodeCountSummary.ManuallyAdded.Initializing != nil {
						manuallyAddedMap["initializing"] = nodePoolSet.NodeCountSummary.ManuallyAdded.Initializing
					}

					if nodePoolSet.NodeCountSummary.ManuallyAdded.Normal != nil {
						manuallyAddedMap["normal"] = nodePoolSet.NodeCountSummary.ManuallyAdded.Normal
					}

					if nodePoolSet.NodeCountSummary.ManuallyAdded.Total != nil {
						manuallyAddedMap["total"] = nodePoolSet.NodeCountSummary.ManuallyAdded.Total
					}

					nodeCountSummaryMap["manually_added"] = []interface{}{manuallyAddedMap}
				}

				autoscalingAddedMap := map[string]interface{}{}

				if nodePoolSet.NodeCountSummary.AutoscalingAdded != nil {
					if nodePoolSet.NodeCountSummary.AutoscalingAdded.Joining != nil {
						autoscalingAddedMap["joining"] = nodePoolSet.NodeCountSummary.AutoscalingAdded.Joining
					}

					if nodePoolSet.NodeCountSummary.AutoscalingAdded.Initializing != nil {
						autoscalingAddedMap["initializing"] = nodePoolSet.NodeCountSummary.AutoscalingAdded.Initializing
					}

					if nodePoolSet.NodeCountSummary.AutoscalingAdded.Normal != nil {
						autoscalingAddedMap["normal"] = nodePoolSet.NodeCountSummary.AutoscalingAdded.Normal
					}

					if nodePoolSet.NodeCountSummary.AutoscalingAdded.Total != nil {
						autoscalingAddedMap["total"] = nodePoolSet.NodeCountSummary.AutoscalingAdded.Total
					}

					nodeCountSummaryMap["autoscaling_added"] = []interface{}{autoscalingAddedMap}
				}

				nodePoolSetMap["node_count_summary"] = []interface{}{nodeCountSummaryMap}
			}

			if nodePoolSet.AutoscalingGroupStatus != nil {
				nodePoolSetMap["autoscaling_group_status"] = nodePoolSet.AutoscalingGroupStatus
			}

			if nodePoolSet.MaxNodesNum != nil {
				nodePoolSetMap["max_nodes_num"] = nodePoolSet.MaxNodesNum
			}

			if nodePoolSet.MinNodesNum != nil {
				nodePoolSetMap["min_nodes_num"] = nodePoolSet.MinNodesNum
			}

			if nodePoolSet.DesiredNodesNum != nil {
				nodePoolSetMap["desired_nodes_num"] = nodePoolSet.DesiredNodesNum
			}

			if nodePoolSet.NodePoolOs != nil {
				nodePoolSetMap["node_pool_os"] = nodePoolSet.NodePoolOs
			}

			if nodePoolSet.OsCustomizeType != nil {
				nodePoolSetMap["os_customize_type"] = nodePoolSet.OsCustomizeType
			}

			if nodePoolSet.ImageId != nil {
				nodePoolSetMap["image_id"] = nodePoolSet.ImageId
			}

			if nodePoolSet.DesiredPodNum != nil {
				nodePoolSetMap["desired_pod_num"] = nodePoolSet.DesiredPodNum
			}

			if nodePoolSet.UserScript != nil {
				nodePoolSetMap["user_script"] = nodePoolSet.UserScript
			}

			tagsList := make([]map[string]interface{}, 0, len(nodePoolSet.Tags))
			if nodePoolSet.Tags != nil {
				for _, tags := range nodePoolSet.Tags {
					tagsMap := map[string]interface{}{}

					if tags.Key != nil {
						tagsMap["key"] = tags.Key
					}

					if tags.Value != nil {
						tagsMap["value"] = tags.Value
					}

					tagsList = append(tagsList, tagsMap)
				}

				nodePoolSetMap["tags"] = tagsList
			}
			if nodePoolSet.DeletionProtection != nil {
				nodePoolSetMap["deletion_protection"] = nodePoolSet.DeletionProtection
			}

			extraArgsMap := map[string]interface{}{}

			if nodePoolSet.ExtraArgs != nil {
				if nodePoolSet.ExtraArgs.Kubelet != nil {
					extraArgsMap["kubelet"] = nodePoolSet.ExtraArgs.Kubelet
				}

				nodePoolSetMap["extra_args"] = []interface{}{extraArgsMap}
			}

			gPUArgsMap := map[string]interface{}{}

			if nodePoolSet.GPUArgs != nil {
				if nodePoolSet.GPUArgs.MIGEnable != nil {
					gPUArgsMap["mig_enable"] = nodePoolSet.GPUArgs.MIGEnable
				}

				driverMap := map[string]interface{}{}

				if nodePoolSet.GPUArgs.Driver != nil {
					if nodePoolSet.GPUArgs.Driver.Version != nil {
						driverMap["version"] = nodePoolSet.GPUArgs.Driver.Version
					}

					if nodePoolSet.GPUArgs.Driver.Name != nil {
						driverMap["name"] = nodePoolSet.GPUArgs.Driver.Name
					}

					gPUArgsMap["driver"] = []interface{}{driverMap}
				}

				cUDAMap := map[string]interface{}{}

				if nodePoolSet.GPUArgs.CUDA != nil {
					if nodePoolSet.GPUArgs.CUDA.Version != nil {
						cUDAMap["version"] = nodePoolSet.GPUArgs.CUDA.Version
					}

					if nodePoolSet.GPUArgs.CUDA.Name != nil {
						cUDAMap["name"] = nodePoolSet.GPUArgs.CUDA.Name
					}

					gPUArgsMap["cuda"] = []interface{}{cUDAMap}
				}

				cUDNNMap := map[string]interface{}{}

				if nodePoolSet.GPUArgs.CUDNN != nil {
					if nodePoolSet.GPUArgs.CUDNN.Version != nil {
						cUDNNMap["version"] = nodePoolSet.GPUArgs.CUDNN.Version
					}

					if nodePoolSet.GPUArgs.CUDNN.Name != nil {
						cUDNNMap["name"] = nodePoolSet.GPUArgs.CUDNN.Name
					}

					if nodePoolSet.GPUArgs.CUDNN.DocName != nil {
						cUDNNMap["doc_name"] = nodePoolSet.GPUArgs.CUDNN.DocName
					}

					if nodePoolSet.GPUArgs.CUDNN.DevName != nil {
						cUDNNMap["dev_name"] = nodePoolSet.GPUArgs.CUDNN.DevName
					}

					gPUArgsMap["cudnn"] = []interface{}{cUDNNMap}
				}

				customDriverMap := map[string]interface{}{}

				if nodePoolSet.GPUArgs.CustomDriver != nil {
					if nodePoolSet.GPUArgs.CustomDriver.Address != nil {
						customDriverMap["address"] = nodePoolSet.GPUArgs.CustomDriver.Address
					}

					gPUArgsMap["custom_driver"] = []interface{}{customDriverMap}
				}

				nodePoolSetMap["gpu_args"] = []interface{}{gPUArgsMap}
			}

			if nodePoolSet.DockerGraphPath != nil {
				nodePoolSetMap["docker_graph_path"] = nodePoolSet.DockerGraphPath
			}

			dataDisksList := make([]map[string]interface{}, 0, len(nodePoolSet.DataDisks))
			if nodePoolSet.DataDisks != nil {
				for _, dataDisks := range nodePoolSet.DataDisks {
					dataDisksMap := map[string]interface{}{}

					if dataDisks.DiskType != nil {
						dataDisksMap["disk_type"] = dataDisks.DiskType
					}

					if dataDisks.FileSystem != nil {
						dataDisksMap["file_system"] = dataDisks.FileSystem
					}

					if dataDisks.DiskSize != nil {
						dataDisksMap["disk_size"] = dataDisks.DiskSize
					}

					if dataDisks.AutoFormatAndMount != nil {
						dataDisksMap["auto_format_and_mount"] = dataDisks.AutoFormatAndMount
					}

					if dataDisks.MountTarget != nil {
						dataDisksMap["mount_target"] = dataDisks.MountTarget
					}

					if dataDisks.DiskPartition != nil {
						dataDisksMap["disk_partition"] = dataDisks.DiskPartition
					}

					dataDisksList = append(dataDisksList, dataDisksMap)
				}

				nodePoolSetMap["data_disks"] = dataDisksList
			}
			if nodePoolSet.Unschedulable != nil {
				nodePoolSetMap["unschedulable"] = nodePoolSet.Unschedulable
			}

			if nodePoolSet.PreStartUserScript != nil {
				nodePoolSetMap["pre_start_user_script"] = nodePoolSet.PreStartUserScript
			}

			ids = append(ids, nodePoolId)
			nodePoolSetList = append(nodePoolSetList, nodePoolSetMap)
		}

		_ = d.Set("node_pool_set", nodePoolSetList)
	}

	d.SetId(helper.DataResourceIdsHash(ids))

	output, ok := d.GetOk("result_output_file")
	if ok && output.(string) != "" {
		if e := tccommon.WriteToFile(output.(string), nodePoolSetList); e != nil {
			return e
		}
	}

	return nil
}
