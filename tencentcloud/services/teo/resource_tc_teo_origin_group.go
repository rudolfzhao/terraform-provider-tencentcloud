// Code generated by iacg; DO NOT EDIT.
package teo

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/resource"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	teo "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/teo/v20220901"

	tccommon "github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/common"
	"github.com/tencentcloudstack/terraform-provider-tencentcloud/tencentcloud/internal/helper"
)

func ResourceTencentCloudTeoOriginGroup() *schema.Resource {
	return &schema.Resource{
		Create: resourceTencentCloudTeoOriginGroupCreate,
		Read:   resourceTencentCloudTeoOriginGroupRead,
		Update: resourceTencentCloudTeoOriginGroupUpdate,
		Delete: resourceTencentCloudTeoOriginGroupDelete,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"zone_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Site ID.",
			},

			"origin_group_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "OriginGroup ID.",
			},

			"name": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "OriginGroup Name.",
			},

			"type": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Type of the origin site. Valid values:\n- `GENERAL`: Universal origin site group, only supports adding IP/domain name origin sites, which can be referenced by domain name service, rule engine, four-layer proxy, general load balancing, and HTTP-specific load balancing.\n- `HTTP`: The HTTP-specific origin site group, supports adding IP/domain name and object storage origin site as the origin site, it cannot be referenced by the four-layer proxy, it can only be added to the acceleration domain name, rule engine-modify origin site, and HTTP-specific load balancing reference.",
			},

			"records": {
				Type:        schema.TypeSet,
				Required:    true,
				Description: "Origin site records.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"record": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Origin site record value, does not include port information, can be: IPv4, IPv6, domain name format.",
						},
						"type": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: "Origin site type, the values are:\n  - `IP_DOMAIN`: IPV4, IPV6, domain name type origin site.\n  - `COS`: COS source.\n  - `AWS_S3`: AWS S3 object storage origin site.",
						},
						"record_id": {
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
							Description: "Origin record ID.",
						},
						"weight": {
							Type:        schema.TypeInt,
							Optional:    true,
							Description: "The weight of the origin site, the value is 0-100. If it is not filled in, it means that the weight will not be set and the system will schedule it freely. If it is filled in with 0, it means that the weight is 0 and the traffic will not be scheduled to this origin site.",
						},
						"private": {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     false,
							Description: "Whether to use private authentication, it takes effect when the origin site type RecordType=COS/AWS_S3, the values are:\n  - `true`: Use private authentication.\n  - `false`: Do not use private authentication.",
						},
						"private_parameters": {
							Type:        schema.TypeList,
							Optional:    true,
							Description: "Parameters for private authentication. Only valid when `Private` is `true`.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"name": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Private authentication parameter name, the values are:\n  - `AccessKeyId`: Authentication parameter Access Key ID.\n  - `SecretAccessKey`: Authentication parameter Secret Access Key.\n  - `SignatureVersion`: Authentication version, v2 or v4.\n  - `Region`: Bucket region.",
									},
									"value": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Private authentication parameter value.",
									},
								},
							},
						},
					},
				},
			},

			"host_header": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Back-to-origin Host Header, it only takes effect when type = HTTP is passed in. The rule engine modifies the Host Header configuration priority to be higher than the Host Header of the origin site group.",
			},

			"references": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: "List of referenced instances of the origin site group.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"instance_type": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Reference service type, the values are:\n  - `AccelerationDomain`: Acceleration domain name.\n  - `RuleEngine`: Rule engine.\n  - `Loadbalance`: Load balancing.\n  - `ApplicationProxy`: Four-layer proxy.",
						},
						"instance_id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "The instance ID of the reference type.",
						},
						"instance_name": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "Instance name of the application type.",
						},
					},
				},
			},

			"create_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Origin site group creation time.",
			},

			"update_time": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "Origin site group update time.",
			},
		},
	}
}

func resourceTencentCloudTeoOriginGroupCreate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_origin_group.create")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	var (
		zoneId        string
		originGroupId string
	)
	var (
		request  = teo.NewCreateOriginGroupRequest()
		response = teo.NewCreateOriginGroupResponse()
	)

	if v, ok := d.GetOk("zone_id"); ok {
		zoneId = v.(string)
	}

	request.ZoneId = helper.String(zoneId)

	if v, ok := d.GetOk("name"); ok {
		request.Name = helper.String(v.(string))
	}

	if v, ok := d.GetOk("type"); ok {
		request.Type = helper.String(v.(string))
	}

	if v, ok := d.GetOk("records"); ok {
		for _, item := range v.(*schema.Set).List() {
			recordsMap := item.(map[string]interface{})
			originRecord := teo.OriginRecord{}
			if v, ok := recordsMap["record"]; ok {
				originRecord.Record = helper.String(v.(string))
			}
			if v, ok := recordsMap["type"]; ok {
				originRecord.Type = helper.String(v.(string))
			}
			if v, ok := recordsMap["record_id"]; ok {
				originRecord.RecordId = helper.String(v.(string))
			}
			if v, ok := recordsMap["weight"]; ok {
				originRecord.Weight = helper.IntUint64(v.(int))
			}
			if v, ok := recordsMap["private"]; ok {
				originRecord.Private = helper.Bool(v.(bool))
			}
			if v, ok := recordsMap["private_parameters"]; ok {
				for _, item := range v.([]interface{}) {
					privateParametersMap := item.(map[string]interface{})
					privateParameter := teo.PrivateParameter{}
					if v, ok := privateParametersMap["name"]; ok {
						privateParameter.Name = helper.String(v.(string))
					}
					if v, ok := privateParametersMap["value"]; ok {
						privateParameter.Value = helper.String(v.(string))
					}
					originRecord.PrivateParameters = append(originRecord.PrivateParameters, &privateParameter)
				}
			}
			request.Records = append(request.Records, &originRecord)
		}
	}

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoClient().CreateOriginGroupWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s create teo origin group failed, reason:%+v", logId, err)
		return err
	}

	originGroupId = *response.Response.OriginGroupId

	d.SetId(strings.Join([]string{zoneId, originGroupId}, tccommon.FILED_SP))

	return resourceTencentCloudTeoOriginGroupRead(d, meta)
}

func resourceTencentCloudTeoOriginGroupRead(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_origin_group.read")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	service := TeoService{client: meta.(tccommon.ProviderMeta).GetAPIV3Conn()}

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	originGroupId := idSplit[1]

	_ = d.Set("zone_id", zoneId)

	respData, err := service.DescribeTeoOriginGroupById(ctx, originGroupId)
	if err != nil {
		return err
	}

	if respData == nil {
		d.SetId("")
		log.Printf("[WARN]%s resource `teo_origin_group` [%s] not found, please check if it has been deleted.\n", logId, d.Id())
		return nil
	}
	if respData.GroupId != nil {
		_ = d.Set("origin_group_id", respData.GroupId)
		originGroupId = *respData.GroupId
	}

	if respData.Name != nil {
		_ = d.Set("name", respData.Name)
	}

	if respData.Type != nil {
		_ = d.Set("type", respData.Type)
	}

	recordsList := make([]map[string]interface{}, 0, len(respData.Records))
	if respData.Records != nil {
		for _, records := range respData.Records {
			recordsMap := map[string]interface{}{}

			if records.Record != nil {
				recordsMap["record"] = records.Record
			}

			if records.Type != nil {
				recordsMap["type"] = records.Type
			}

			if records.RecordId != nil {
				recordsMap["record_id"] = records.RecordId
			}

			if records.Weight != nil {
				recordsMap["weight"] = records.Weight
			}

			if records.Private != nil {
				recordsMap["private"] = records.Private
			}

			privateParametersList := make([]map[string]interface{}, 0, len(records.PrivateParameters))
			if records.PrivateParameters != nil {
				for _, privateParameters := range records.PrivateParameters {
					privateParametersMap := map[string]interface{}{}

					if privateParameters.Name != nil {
						privateParametersMap["name"] = privateParameters.Name
					}

					if privateParameters.Value != nil {
						privateParametersMap["value"] = privateParameters.Value
					}

					privateParametersList = append(privateParametersList, privateParametersMap)
				}

				recordsMap["private_parameters"] = privateParametersList
			}
			recordsList = append(recordsList, recordsMap)
		}

		_ = d.Set("records", recordsList)
	}

	referencesList := make([]map[string]interface{}, 0, len(respData.References))
	if respData.References != nil {
		for _, references := range respData.References {
			referencesMap := map[string]interface{}{}

			if references.InstanceType != nil {
				referencesMap["instance_type"] = references.InstanceType
			}

			if references.InstanceId != nil {
				referencesMap["instance_id"] = references.InstanceId
			}

			if references.InstanceName != nil {
				referencesMap["instance_name"] = references.InstanceName
			}

			referencesList = append(referencesList, referencesMap)
		}

		_ = d.Set("references", referencesList)
	}

	if respData.CreateTime != nil {
		_ = d.Set("create_time", respData.CreateTime)
	}

	if respData.UpdateTime != nil {
		_ = d.Set("update_time", respData.UpdateTime)
	}

	if respData.HostHeader != nil {
		_ = d.Set("host_header", respData.HostHeader)
	}

	_ = zoneId
	return nil
}

func resourceTencentCloudTeoOriginGroupUpdate(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_origin_group.update")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)

	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	originGroupId := idSplit[1]

	needChange := false
	mutableArgs := []string{"name", "type", "records", "host_header"}
	for _, v := range mutableArgs {
		if d.HasChange(v) {
			needChange = true
			break
		}
	}

	if needChange {
		request := teo.NewModifyOriginGroupRequest()

		request.ZoneId = helper.String(zoneId)

		request.GroupId = helper.String(originGroupId)

		if v, ok := d.GetOk("name"); ok {
			request.Name = helper.String(v.(string))
		}

		if v, ok := d.GetOk("type"); ok {
			request.Type = helper.String(v.(string))
		}

		if v, ok := d.GetOk("records"); ok {
			for _, item := range v.(*schema.Set).List() {
				recordsMap := item.(map[string]interface{})
				originRecord := teo.OriginRecord{}
				if v, ok := recordsMap["record"]; ok {
					originRecord.Record = helper.String(v.(string))
				}
				if v, ok := recordsMap["type"]; ok {
					originRecord.Type = helper.String(v.(string))
				}
				if v, ok := recordsMap["record_id"]; ok {
					originRecord.RecordId = helper.String(v.(string))
				}
				if v, ok := recordsMap["weight"]; ok {
					originRecord.Weight = helper.IntUint64(v.(int))
				}
				if v, ok := recordsMap["private"]; ok {
					originRecord.Private = helper.Bool(v.(bool))
				}
				if v, ok := recordsMap["private_parameters"]; ok {
					for _, item := range v.([]interface{}) {
						privateParametersMap := item.(map[string]interface{})
						privateParameter := teo.PrivateParameter{}
						if v, ok := privateParametersMap["name"]; ok {
							privateParameter.Name = helper.String(v.(string))
						}
						if v, ok := privateParametersMap["value"]; ok {
							privateParameter.Value = helper.String(v.(string))
						}
						originRecord.PrivateParameters = append(originRecord.PrivateParameters, &privateParameter)
					}
				}
				request.Records = append(request.Records, &originRecord)
			}
		}

		if v, ok := d.GetOk("host_header"); ok {
			request.HostHeader = helper.String(v.(string))
		}

		err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
			result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoClient().ModifyOriginGroupWithContext(ctx, request)
			if e != nil {
				return tccommon.RetryError(e)
			} else {
				log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
			}
			return nil
		})
		if err != nil {
			log.Printf("[CRITAL]%s update teo origin group failed, reason:%+v", logId, err)
			return err
		}
	}

	return resourceTencentCloudTeoOriginGroupRead(d, meta)
}

func resourceTencentCloudTeoOriginGroupDelete(d *schema.ResourceData, meta interface{}) error {
	defer tccommon.LogElapsed("resource.tencentcloud_teo_origin_group.delete")()
	defer tccommon.InconsistentCheck(d, meta)()

	logId := tccommon.GetLogId(tccommon.ContextNil)
	ctx := tccommon.NewResourceLifeCycleHandleFuncContext(context.Background(), logId, d, meta)

	idSplit := strings.Split(d.Id(), tccommon.FILED_SP)
	if len(idSplit) != 2 {
		return fmt.Errorf("id is broken,%s", d.Id())
	}
	zoneId := idSplit[0]
	originGroupId := idSplit[1]

	var (
		request  = teo.NewDeleteOriginGroupRequest()
		response = teo.NewDeleteOriginGroupResponse()
	)

	request.ZoneId = helper.String(zoneId)

	request.GroupId = helper.String(originGroupId)

	err := resource.Retry(tccommon.WriteRetryTimeout, func() *resource.RetryError {
		result, e := meta.(tccommon.ProviderMeta).GetAPIV3Conn().UseTeoClient().DeleteOriginGroupWithContext(ctx, request)
		if e != nil {
			return tccommon.RetryError(e)
		} else {
			log.Printf("[DEBUG]%s api[%s] success, request body [%s], response body [%s]\n", logId, request.GetAction(), request.ToJsonString(), result.ToJsonString())
		}
		response = result
		return nil
	})
	if err != nil {
		log.Printf("[CRITAL]%s delete teo origin group failed, reason:%+v", logId, err)
		return err
	}

	_ = response
	return nil
}
